#!/usr/bin/env php
<?php declare(strict_types=1);

use ju1ius\FusBup\Dafsa\Result;
use ju1ius\FusBup\Tests\GPerfParser;

require_once __DIR__ . '/../vendor/autoload.php';

App::main();

final class App
{
    private const DEFAULTS = [
        'r' => false,
    ];

    public function __construct(
        private readonly string $name,
        private readonly array $options,
        private readonly array $arguments,
    ) {
    }

    public static function main(): never
    {
        $name = basename(__FILE__);
        $options = getopt('rh', ['reverse', 'help'], $index) + self::DEFAULTS;
        $args = array_slice($GLOBALS['argv'], $index);
        $app = new self($name, $options, $args);
        exit($app->run());
    }

    public function run(): int
    {
        if ($this->options['h'] ?? false) {
            return $this->usage(0);
        }
        if (!$inputFile = $this->arguments[0] ?? null) {
            return $this->usage(1);
        }
        if (!$outputDir = $arguments[1] ?? null) {
            $outputDir = dirname($inputFile);
        }
        if (!\is_dir($outputDir)) {
            echo "Not a directory: {$outputDir}\n";
            return $this->usage(1);
        }

        $this->writePsl($inputFile, $outputDir);
        foreach ([false, true] as $reverse) {
            $this->writeByteArray($inputFile, $outputDir, $reverse);
        }
        return 0;
    }

    private function writePsl(string $inputFile, string $outputDir): void
    {
        $sections = [
            'ICANN' => [],
            'PRIVATE' => [],
        ];
        foreach (GPerfParser::iter($inputFile) as [$word, $flags]) {
            if ($flags & Result::Wildcard) {
                $rule = '*.' . $word;
            } else if ($flags & Result::Exception) {
                $rule = '!' . $word;
            } else {
                $rule = $word;
            }
            if ($flags & Result::Private) {
                $sections['PRIVATE'][] = $rule;
            } else {
                $sections['ICANN'][] = $rule;
            }
        }

        $outputName = basename($inputFile, '.gperf');
        $outputFile = new \SplFileObject("{$outputDir}/{$outputName}.txt", 'w');

        $cmd = $this->getCommandLine();
        $outputFile->fwrite("// generated by: {$cmd}\n");

        foreach ($sections as $name => $rules) {
            $outputFile->fwrite("\n// ===BEGIN {$name} DOMAINS===\n");
            foreach ($rules as $rule) {
                $outputFile->fwrite("{$rule}\n");
            }
            $outputFile->fwrite("// ===END {$name} DOMAINS===\n");
        }
    }

    private function writeByteArray(string $inputFile, string $outputDir, bool $reverse): void
    {
        $args = [
            dirname(__DIR__) . '/tools/make_dafsa.py',
        ];
        if ($reverse) {
            $args[] = '--reverse';
        }
        $args[] = realpath($inputFile);
        $proc = proc_open($args, [1 => ['pipe', 'w']], $pipes);
        $output = stream_get_contents($pipes[1]);
        if (proc_close($proc) !== 0 || $output === false) {
            throw new \RuntimeException('Could not make DAFSA.');
        }
        if (!preg_match('/= \{\n(?<bytes>[^}]+)};/', $output, $m)) {
            throw new \RuntimeException("Could not parse output:\n{$output}");
        }

        $outputName = sprintf(
            '%s/%s%s.php',
            $outputDir,
            basename($inputFile, '.gperf'),
            $reverse ? '-rev' : '',
        );
        $outputFile = new \SplFileObject($outputName, 'w');
        $outputFile->fwrite("<?php\n");

        $cmd = $this->getCommandLine();
        $outputFile->fwrite("// generated by: {$cmd}\n");

        $outputFile->fwrite("return [\n");
        $outputFile->fwrite($m['bytes']);
        $outputFile->fwrite("];\n");
    }

    private function usage(int $exitCode): int
    {
        echo <<<EOS

        {$this->name} [-h|--help] <gperf-file> <output-dir>

        Takes a gperf file and outputs:
          * a file in the public suffix list format.
          * a DAFSA automaton as a PHP byte array that can be required
          * a reverse-lookup version of the aforementioned automaton.
          
        # ARGUMENTS
        
        <gperf-file>      The gperf file to process.
        
        <output-dir>      (Optional) Output directory for the generated files.
                          Defaults to the directory of the input file.

        # OPTIONS

          -h|--help       Displays this help message.

        EOS;

        return $exitCode;
    }

    private function getCommandLine(): string
    {
        $cmd = [$this->name];
        if ($this->options['r']) {
            $cmd[] = '--reverse';
        }
        array_push($cmd, ...$this->arguments);

        return implode(' ', array_map(escapeshellarg(...), $cmd));
    }
}
